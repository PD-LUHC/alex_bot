#' Play an interactive terminal LA guessing game
#'
#' Launch an interactive terminal game that asks the user to guess a UK
#' geography (e.g., Local Authority District, MSOA) selected at random.
#' The game downloads ONS boundaries for the chosen `area_type`, shows an
#' initial map, and then responds to user commands (`hint`, `options`,
#' `reveal`, `quit`) until the round ends.
#'
#' @section How it works:
#' \itemize{
#'   \item Downloads boundaries via \code{ons_get_boundaries()} for the given
#'         \code{area_type}, \code{resolution}, and \code{nations}.
#'   \item Randomly selects a target and opens a plot of the selected area.
#'   \item Provides progressive \strong{hints} either at fixed distances
#'         (\code{hint_mode = "fixed_km"}) or distances \emph{proportional}
#'         to the size of the area (\code{hint_mode = "proportional"}), where
#'         proportional distances are computed from \code{buffer_basis}.
#'   \item Offers multiple-choice \strong{options} drawn from nearby areas.
#' }
#'
#' @param area_type Character scalar, one of
#'   \code{"lad"}, \code{"ctyua"}, \code{"msoa"}, \code{"pcon"}.
#'   These correspond to:
#'   \itemize{
#'     \item \code{"lad"} = Local Authority District
#'     \item \code{"ctyua"} = Counties and Unitary Authority
#'     \item \code{"msoa"} = Middle Layer Super Output Area
#'     \item \code{"pcon"} = Parliamentary Constituency
#'   }
#'   Default is \code{"lad"}.
#'
#' @param resolution Character scalar passed to \code{ons_get_boundaries()} to
#'   choose the boundary generalisation. Defaults to \code{"BGC"}.
#'
#' @param nations Named logical vector of length 4 defining which nations to
#'   include when downloading boundaries; names must be \code{c("E","N","S","W")}.
#'   The default is \code{c(E = TRUE, N = FALSE, S = FALSE, W = FALSE)}.
#'
#' @param random_seed Integer or \code{NULL}. If supplied, sets the RNG seed
#'   at the start of the round to ensure reproducibility of the selected area
#'   and the generated options. If \code{NULL} (default), each run is random.
#'
#' @param hint_mode Character scalar; how to generate hint distances. One of:
#'   \code{"proportional"} (default) or \code{"fixed_km"}.
#'   \itemize{
#'     \item \code{"proportional"}: distances are computed as
#'           \code{buffer_scales * unit_km}, where \code{unit_km} depends on
#'           \code{buffer_basis} (see below) and is floored at \code{min_buffer_km}.
#'     \item \code{"fixed_km"}: distances are taken directly from
#'           \code{buffers_km}.
#'   }
#'
#' @param buffers_km Numeric vector of hint distances in kilometres used only
#'   when \code{hint_mode == "fixed_km"}. Default: \code{c(15, 30, 60)}.
#'
#' @param buffer_scales Numeric vector of multipliers used only when
#'   \code{hint_mode == "proportional"}. Default: \code{c(1, 2.5, 5)}.
#'
#' @param buffer_basis Character scalar defining the basis for proportional
#'   hints; one of \code{"maxdim"}, \code{"diag"}, \code{"area_radius"}.
#'   This is passed to \code{.la_size_unit_km()} to compute \code{unit_km}.
#'
#' @param min_buffer_km Numeric scalar. Minimum hint distance (km) applied
#'   when using proportional hints so that very small areas still get a
#'   sensible first hint. Default: \code{5}.
#'
#' @param n_options Integer scalar. Total number of answer options to show
#'   when the user types \code{"options"}. One is correct; the rest are
#'   distractors. Default: \code{4}.
#'
#' @param options_radius_km Numeric scalar. Maximum distance (km) from the
#'   target within which distractor options are sampled. Default: \code{60}.
#'
#' @details
#' The function is \strong{interactive} and runs in a terminal/console loop.
#' It prints messages and uses \code{readline()} to obtain user input.
#' It opens/uses a graphics device and prints ggplots generated by
#' \code{plot_selected()} and \code{plot_with_surroundings()}.
#'
#' The game responds to the following commands typed by the user:
#' \itemize{
#'   \item \code{hint} — show the next hint map at the next distance.
#' @export
LA_game <- function(
    area_type = "lad",
    chatty = FALSE,
    resolution = "BGC",
    nations = c(E = TRUE, N = FALSE, S = FALSE, W = FALSE),
    random_seed = NULL,                     # NULL = random each run; set a number for reproducibility
    hint_mode = c("proportional", "fixed_km"),
    buffers_km = c(15, 30, 60),             # used when hint_mode == "fixed_km"
    buffer_scales = c(1, 2.5, 5),       # used when hint_mode == "proportional"
    buffer_basis = c("maxdim", "diag", "area_radius"),
    min_buffer_km = 5,                      # floor so tiny districts still get a sensible first hint
    n_options = 4,
    options_radius_km = 60
) {
    .require_pkgs(c("sf", "ggplot2"))
    hint_mode <- match.arg(hint_mode)
    buffer_basis <- match.arg(buffer_basis)

    # Only fix the RNG if a seed is provided
    if (!is.null(random_seed)) set.seed(random_seed)


    .welcome_message(area_type, chatty)

    # Download boundaries and pick a target at random (no seed => truly random by default)
    bnd <- ons_get_boundaries(
        area_type = area_type,
        resolution = resolution,
        nations = nations,
        quiet = TRUE
    )

    sel <- pick_entry(bnd, random = TRUE)

    # Compute the hint distances in km
    if (hint_mode == "proportional") {
        unit_km <- .la_size_unit_km(sel, basis = buffer_basis)
        computed_buffers <- pmax(buffer_scales * unit_km, min_buffer_km)
    } else {
        computed_buffers <- buffers_km
    }

    correct <- selected_name(sel)

    typewrite(
        paste("Type your guess, 'hint', 'options', 'reveal', or 'quit'."),
        chatty = FALSE, ellipsis = FALSE
    )
    typewrite(
        paste(
            if (hint_mode == "proportional") {
                paste0(
                    "Hints (proportional, basis = ", buffer_basis, "): ",
                    paste(round(computed_buffers), collapse = " \U2192 "), " km"
                )
            } else {
                paste0("Hints (fixed): ", paste(computed_buffers, collapse = " \U2192 "), " km")
            }
        ),
        chatty = chatty
    )

    # Always ensure a device exists and is active, then plot immediately
    .ensure_plot_device()
    print(plot_selected(sel))

    hint_i <- 0L
    repeat {
        ans <- readline("Your input: ")
        low <- tolower(trimws(ans))

        if (low %in% c("quit", "exit")) {
            typewrite(paste("You quit. The answer was:", correct), chatty = chatty)
            break
        }

        if (low == "reveal") {
            if (chatty) {
                typewrite("Oh dear!", chatty = chatty)
                typewrite("Maybe you'll get it next time", chatty = chatty)
            }
            typewrite(paste("The correct answer is:", correct), chatty = chatty)
            .ensure_plot_device()
            print(plot_selected(sel, show_title = TRUE, title_position = "top", title_size = 22))
            break
        }

        if (low == "hint") {
            hint_i <- hint_i + 1L
            if (hint_i == 2) {
                .oh_gosh_cat(chatty)
            }
            if (hint_i == 3) {
                .history_is_great(chatty)
            }
            if (hint_i > length(computed_buffers)) {
                typewrite(
                    "No more hints. Try 'reveal', see 'options', or make a guess.",
                    chatty = chatty
                )
            } else {
                d <- computed_buffers[hint_i]
                typewrite(
                    paste("Showing surroundings at", round(d, 1), "km"),
                    chatty = chatty
                )
                .ensure_plot_device()
                print(plot_with_surroundings(
                    sel,
                    distance_km = d,
                    hint_label = paste0("HINT ", hint_i, " – ", round(d, 1), " km")
                ))
            }
            next
        }

        if (low == "options") {
            # Keep options random unless the user asked for reproducibility via random_seed
            opts <- guess_options(
                sel,
                n_distractors = max(0, n_options - 1L),
                max_distance_km = options_radius_km,
                seed = if (!is.null(random_seed)) random_seed else NULL
            )
            cat("Options:\n")
            for (i in seq_along(opts)) cat(sprintf("  %d) %s\n", i, opts[i]))
            next
        }

        if (nchar(low) == 0) next

        if (low == tolower(correct)) {
            typewrite(paste("\U2705 Correct! ", correct), chatty = chatty)
            .ensure_plot_device()
            print(plot_selected(sel, show_title = TRUE, title_position = "top", title_size = 22))
            break
        } else {
            typewrite(
                "\U274C Not correct. Try 'hint', 'options', or 'reveal'.",
                chatty = chatty
            )
        }
    }
}